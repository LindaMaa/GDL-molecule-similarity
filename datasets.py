# -*- coding: utf-8 -*-
"""datasets.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AoPMtl4QzVzcCUxvn5114nSFUnFCKiZV
"""

dataset = QM9(root='data/QM9')
import torch_geometric
from torch_geometric.datasets import QM9
from torch_geometric.data import Batch, DataLoader, Data, Dataset, InMemoryDataset
from rdkit import Chem, DataStructs
from rdkit.Chem import AllChem, Crippen, QED, rdMolDescriptors, rdmolops
from rdkit.Avalon.pyAvalonTools import GetAvalonFP
from rdkit import Chem, DataStructs
from rdkit.Chem import rdMolDescriptors
from scipy.stats import pearsonr
from rdkit.Chem import rdFingerprintGenerator, RDKFingerprint

class QM9MoleculeSimilarityDataset(InMemoryDataset):
    def __init__(self, dataset, threshold=0.7, positive_ratio=0.5):
        self.dataset = dataset
        self.threshold = threshold
        self.positive_ratio = positive_ratio
        super(QM9MoleculeSimilarityDataset, self).__init__(dataset.root)
        self.data, self.slices = torch.load(self.processed_paths[0])

    @property
    def raw_file_names(self):
        return []

    @property
    def processed_file_names(self):
        return ['processed_mol_similarity_data.pt']

    def download(self):
        pass

    def process(self):
        data_list = []
        for i in range(len(self.dataset)):
            data1, data2, label = self.get(i)
            data = Data(data1=data1, data2=data2, y=label)
            data_list.append(data)

        data, slices = self.collate(data_list)
        torch.save((data, slices), self.processed_paths[0])


    def __len__(self):
        return len(self.dataset)

    def _get_fingerprint(self, mol):
        return rdMolDescriptors.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)

    def _compute_similarity(self, mol1, mol2):
        fp1 = self._get_fingerprint(mol1)
        fp2 = self._get_fingerprint(mol2)
        return DataStructs.TanimotoSimilarity(fp1, fp2)

    def _get_positive_pair(self, index):
      data1 = self.dataset[index]
      mol1 = self._get_rdkit_mol(data1)
      for _ in range(30): 
          other_index = random.randint(0, len(self.dataset) - 1)
          data2 = self.dataset[other_index]
          mol2 = self._get_rdkit_mol(data2)
          similarity = self._compute_similarity(mol1, mol2)
          if similarity >= self.threshold:
              return self.dataset[index], self.dataset[other_index], torch.tensor([1.0], dtype=torch.float)
      return None, None, None

    def _get_negative_pair(self, index):
        data1 = self.dataset[index]
        mol1 = self._get_rdkit_mol(data1)
        for _ in range(30):  
            other_index = random.randint(0, len(self.dataset) - 1)
            data2 = self.dataset[other_index]
            mol2 = self._get_rdkit_mol(data2)
            similarity = self._compute_similarity(mol1, mol2)
            if similarity < self.threshold:
                return self.dataset[index], self.dataset[other_index], torch.tensor([0.0], dtype=torch.float)
        return None, None, None



    def _get_rdkit_mol(self, data):
      atomic_numbers = data.z.tolist()
      positions = data.pos.tolist()

      mol = Chem.EditableMol(Chem.Mol())
      for z in atomic_numbers:
          mol.AddAtom(Chem.Atom(int(z)))

      mol = mol.GetMol()

      conf = Chem.Conformer(len(atomic_numbers))
      for i, pos in enumerate(positions):
          conf.SetAtomPosition(i, pos)
      mol.AddConformer(conf)
      Chem.SanitizeMol(mol)

      return mol

    def _compute_similarity(self, mol1, mol2):
      fp1 = self._get_fingerprint(mol1)
      fp2 = self._get_fingerprint(mol2)
      similarity = DataStructs.FingerprintSimilarity(fp1, fp2)
      return similarity


    def get(self, index):
        is_positive = random.random() < self.positive_ratio
        if is_positive:
            data1, data2, label = self._get_positive_pair(index)
            if data1 is not None and data2 is not None:
                return data1, data2, label
        else:
            data1, data2, label = self._get_negative_pair(index)
            if data1 is not None and data2 is not None:
                return data1, data2, label

        other_index = random.randint(0, len(self.dataset) - 1)
        return self.dataset[index], self.dataset[other_index], torch.tensor([0.0], dtype=torch.float)

class QM9MoleculeSimilarityDatasetTopological(InMemoryDataset):
    def __init__(self, dataset, threshold=0.7, positive_ratio=0.5):
        self.dataset = dataset
        self.threshold = threshold
        self.positive_ratio = positive_ratio
        super(QM9MoleculeSimilarityDatasetTopological, self).__init__(dataset.root)
        self.data, self.slices = torch.load(self.processed_paths[0])

    @property
    def raw_file_names(self):
        return []

    @property
    def processed_file_names(self):
        return ['processed_mol_similarity_data.pt']

    def download(self):
        pass

    def process(self):
        data_list = []
        for i in range(len(self.dataset)):
            data1, data2, label = self.get(i)
            data = Data(data1=data1, data2=data2, y=label)
            data_list.append(data)

        data, slices = self.collate(data_list)
        torch.save((data, slices), self.processed_paths[0])


    def __len__(self):
        return len(self.dataset)

    def _get_fingerprint(self, mol):
        return rdFingerprintGenerator.GetFPs([mol])[0]

    def _compute_similarity(self, mol1, mol2):
        fp1 = self._get_fingerprint(mol1)
        fp2 = self._get_fingerprint(mol2)
        return DataStructs.TanimotoSimilarity(fp1, fp2)

    def _get_positive_pair(self, index):
      data1 = self.dataset[index]
      mol1 = self._get_rdkit_mol(data1)
      for _ in range(30): 
          other_index = random.randint(0, len(self.dataset) - 1)
          data2 = self.dataset[other_index]
          mol2 = self._get_rdkit_mol(data2)
          similarity = self._compute_similarity(mol1, mol2)
          if similarity >= self.threshold:
              return self.dataset[index], self.dataset[other_index], torch.tensor([1], dtype=torch.float)
      return None, None, None

    def _get_negative_pair(self, index):
        data1 = self.dataset[index]
        mol1 = self._get_rdkit_mol(data1)
        for _ in range(30):  
            other_index = random.randint(0, len(self.dataset) - 1)
            data2 = self.dataset[other_index]
            mol2 = self._get_rdkit_mol(data2)
            similarity = self._compute_similarity(mol1, mol2)
            if similarity < self.threshold:
                return self.dataset[index], self.dataset[other_index], torch.tensor([0], dtype=torch.float)
        return None, None, None



    def _get_rdkit_mol(self, data):
      atomic_numbers = data.z.tolist()
      positions = data.pos.tolist()

      mol = Chem.EditableMol(Chem.Mol())
      for z in atomic_numbers:
          mol.AddAtom(Chem.Atom(int(z)))

      mol = mol.GetMol()

      conf = Chem.Conformer(len(atomic_numbers))
      for i, pos in enumerate(positions):
          conf.SetAtomPosition(i, pos)
      mol.AddConformer(conf)
      Chem.SanitizeMol(mol)

      return mol

    def _compute_similarity(self, mol1, mol2):
      fp1 = self._get_fingerprint(mol1)
      fp2 = self._get_fingerprint(mol2)
      similarity = DataStructs.FingerprintSimilarity(fp1, fp2)
      return similarity


    def get(self, index):
        is_positive = random.random() < self.positive_ratio
        if is_positive:
            data1, data2, label = self._get_positive_pair(index)
            if data1 is not None and data2 is not None:
                return data1, data2, label
        else:
            data1, data2, label = self._get_negative_pair(index)
            if data1 is not None and data2 is not None:
                return data1, data2, label
        other_index = random.randint(0, len(self.dataset) - 1)
        return self.dataset[index], self.dataset[other_index], torch.tensor([0.0], dtype=torch.float)

class QM9MoleculeSimilarityDatasetAvalon(InMemoryDataset):
    def __init__(self, dataset, threshold=0.7, positive_ratio=0.5):
        self.dataset = dataset
        self.threshold = threshold
        self.positive_ratio = positive_ratio
        super(QM9MoleculeSimilarityDatasetAvalon, self).__init__(dataset.root)
        self.data, self.slices = torch.load(self.processed_paths[0])

    @property
    def raw_file_names(self):
        return []

    @property
    def processed_file_names(self):
        return ['processed_mol_similarity_data.pt']

    def download(self):
        pass

    def process(self):
        data_list = []
        for i in range(len(self.dataset)):
            data1, data2, label = self.get(i)
            data = Data(data1=data1, data2=data2, y=label)
            data_list.append(data)

        data, slices = self.collate(data_list)
        torch.save((data, slices), self.processed_paths[0])


    def __len__(self):
        return len(self.dataset)

    def _get_fingerprint(self, mol):
        return GetAvalonFP(mol)

    def _compute_similarity(self, mol1, mol2):
        fp1 = self._get_fingerprint(mol1)
        fp2 = self._get_fingerprint(mol2)
        return DataStructs.TanimotoSimilarity(fp1, fp2)

    def _get_positive_pair(self, index):
      data1 = self.dataset[index]
      mol1 = self._get_rdkit_mol(data1)
      for _ in range(30):  
          other_index = random.randint(0, len(self.dataset) - 1)
          data2 = self.dataset[other_index]
          mol2 = self._get_rdkit_mol(data2)
          similarity = self._compute_similarity(mol1, mol2)
          if similarity >= self.threshold:
              return self.dataset[index], self.dataset[other_index], torch.tensor([1], dtype=torch.float)
      return None, None, None

    def _get_negative_pair(self, index):
        data1 = self.dataset[index]
        mol1 = self._get_rdkit_mol(data1)
        for _ in range(30):  
            other_index = random.randint(0, len(self.dataset) - 1)
            data2 = self.dataset[other_index]
            mol2 = self._get_rdkit_mol(data2)
            similarity = self._compute_similarity(mol1, mol2)
            if similarity < self.threshold:
                return self.dataset[index], self.dataset[other_index], torch.tensor([0], dtype=torch.float)
        return None, None, None

    def _get_rdkit_mol(self, data):
      atomic_numbers = data.z.tolist()
      positions = data.pos.tolist()

      mol = Chem.EditableMol(Chem.Mol())
      for z in atomic_numbers:
          mol.AddAtom(Chem.Atom(int(z)))

      mol = mol.GetMol()

      conf = Chem.Conformer(len(atomic_numbers))
      for i, pos in enumerate(positions):
          conf.SetAtomPosition(i, pos)
      mol.AddConformer(conf)
      Chem.SanitizeMol(mol)

      return mol


    def _compute_similarity(self, mol1, mol2):
      fp1 = self._get_fingerprint(mol1)
      fp2 = self._get_fingerprint(mol2)
      similarity, _ = pearsonr(fp1, fp2)
      return similarity


    def get(self, index):
        is_positive = random.random() < self.positive_ratio
        if is_positive:
            data1, data2, label = self._get_positive_pair(index)
            if data1 is not None and data2 is not None:
                return data1, data2, label
        else:
            data1, data2, label = self._get_negative_pair(index)
            if data1 is not None and data2 is not None:
                return data1, data2, label
        other_index = random.randint(0, len(self.dataset) - 1)
        return self.dataset[index], self.dataset[other_index], torch.tensor([0.0], dtype=torch.float)

class QM9MoleculeSimilarityDatasetPath(InMemoryDataset):
    def __init__(self, dataset, threshold=0.7, positive_ratio=0.5):
        self.dataset = dataset
        self.threshold = threshold
        self.positive_ratio = positive_ratio
        super(QM9MoleculeSimilarityDatasetPath, self).__init__(dataset.root)
        self.data, self.slices = torch.load(self.processed_paths[0])

    @property
    def raw_file_names(self):
        return []

    @property
    def processed_file_names(self):
        return ['processed_mol_similarity_data.pt']

    def download(self):
        pass

    def process(self):
        data_list = []
        for i in range(len(self.dataset)):
            data1, data2, label = self.get(i)
            data = Data(data1=data1, data2=data2, y=label)
            data_list.append(data)

        data, slices = self.collate(data_list)
        torch.save((data, slices), self.processed_paths[0])

    def __len__(self):
        return len(self.dataset)

    def _get_fingerprint(self, mol):
        return RDKFingerprint(mol)

    def _compute_similarity(self, mol1, mol2):
        fp1 = self._get_fingerprint(mol1)
        fp2 = self._get_fingerprint(mol2)
        similarity = DataStructs.FingerprintSimilarity(fp1, fp2)
        return similarity



    def _get_positive_pair(self, index):
      data1 = self.dataset[index]
      mol1 = self._get_rdkit_mol(data1)
      for _ in range(10):
          other_index = random.randint(0, len(self.dataset) - 1)
          data2 = self.dataset[other_index]
          mol2 = self._get_rdkit_mol(data2)
          similarity = self._compute_similarity(mol1, mol2)
          if similarity >= self.threshold:
              return self.dataset[index], self.dataset[other_index], torch.tensor([1], dtype=torch.float)
      return None, None, None

    def _get_negative_pair(self, index):
        data1 = self.dataset[index]
        mol1 = self._get_rdkit_mol(data1)
        for _ in range(10):  
            other_index = random.randint(0, len(self.dataset) - 1)
            data2 = self.dataset[other_index]
            mol2 = self._get_rdkit_mol(data2)
            similarity = self._compute_similarity(mol1, mol2)
            if similarity < self.threshold:
                return self.dataset[index], self.dataset[other_index], torch.tensor([0], dtype=torch.float)
        return None, None, None



    def _get_rdkit_mol(self, data):
      atomic_numbers = data.z.tolist()
      positions = data.pos.tolist()

      mol = Chem.EditableMol(Chem.Mol())
      for z in atomic_numbers:
          mol.AddAtom(Chem.Atom(int(z)))

      mol = mol.GetMol()

      conf = Chem.Conformer(len(atomic_numbers))
      for i, pos in enumerate(positions):
          conf.SetAtomPosition(i, pos)
      mol.AddConformer(conf)
      Chem.SanitizeMol(mol)

      return mol



    def _compute_similarity(self, mol1, mol2):
      fp1 = self._get_fingerprint(mol1)
      fp2 = self._get_fingerprint(mol2)
      similarity = DataStructs.FingerprintSimilarity(fp1, fp2)
      return similarity


    def get(self, index):
        is_positive = random.random() < self.positive_ratio
        if is_positive:
            data1, data2, label = self._get_positive_pair(index)
            if data1 is not None and data2 is not None:
                return data1, data2, label
        else:
            data1, data2, label = self._get_negative_pair(index)
            if data1 is not None and data2 is not None:
                return data1, data2, label

        other_index = random.randint(0, len(self.dataset) - 1)
        return self.dataset[index], self.dataset[other_index], torch.tensor([0.0], dtype=torch.float)

class QM9MoleculeSimilarityDatasetTorsion(InMemoryDataset):
    def __init__(self, dataset, threshold=0.7, positive_ratio=0.5):
        self.dataset = dataset
        self.threshold = threshold
        self.positive_ratio = positive_ratio
        super(QM9MoleculeSimilarityDatasetTorsion, self).__init__(dataset.root)
        self.data, self.slices = torch.load(self.processed_paths[0])

    @property
    def raw_file_names(self):
        return []

    @property
    def processed_file_names(self):
        return ['processed_mol_similarity_data.pt']

    def download(self):
        pass

    def process(self):
        data_list = []
        for i in range(len(self.dataset)):
            data1, data2, label = self.get(i)
            data = Data(data1=data1, data2=data2, y=label)
            data_list.append(data)

        data, slices = self.collate(data_list)
        torch.save((data, slices), self.processed_paths[0])

    def __len__(self):
        return len(self.dataset)

    def _get_fingerprint(self, mol):
        return rdMolDescriptors.GetHashedTopologicalTorsionFingerprintAsBitVect(mol, nBits=2048)

    def _compute_similarity(self, mol1, mol2):
        fp1 = self._get_fingerprint(mol1)
        fp2 = self._get_fingerprint(mol2)
        return DataStructs.TanimotoSimilarity(fp1, fp2)


    def _get_positive_pair(self, index):
      data1 = self.dataset[index]
      mol1 = self._get_rdkit_mol(data1)
      for _ in range(10): 
          other_index = random.randint(0, len(self.dataset) - 1)
          data2 = self.dataset[other_index]
          mol2 = self._get_rdkit_mol(data2)
          similarity = self._compute_similarity(mol1, mol2)
          if similarity >= self.threshold:
              return self.dataset[index], self.dataset[other_index], torch.tensor([1], dtype=torch.float)
      return None, None, None

    def _get_negative_pair(self, index):
        data1 = self.dataset[index]
        mol1 = self._get_rdkit_mol(data1)
        for _ in range(10): 
            other_index = random.randint(0, len(self.dataset) - 1)
            data2 = self.dataset[other_index]
            mol2 = self._get_rdkit_mol(data2)
            similarity = self._compute_similarity(mol1, mol2)
            if similarity < self.threshold:
                return self.dataset[index], self.dataset[other_index], torch.tensor([0], dtype=torch.float)
        return None, None, None



    def _get_rdkit_mol(self, data):
      atomic_numbers = data.z.tolist()
      positions = data.pos.tolist()

      mol = Chem.EditableMol(Chem.Mol())
      for z in atomic_numbers:
          mol.AddAtom(Chem.Atom(int(z)))

      mol = mol.GetMol()

      conf = Chem.Conformer(len(atomic_numbers))
      for i, pos in enumerate(positions):
          conf.SetAtomPosition(i, pos)
      mol.AddConformer(conf)
      Chem.SanitizeMol(mol)

      return mol
    
    def _compute_similarity(self, mol1, mol2):
      fp1 = self._get_fingerprint(mol1)
      fp2 = self._get_fingerprint(mol2)
      similarity, _ = pearsonr(fp1, fp2)
      return similarity


 


    def get(self, index):
        is_positive = random.random() < self.positive_ratio
        if is_positive:
            data1, data2, label = self._get_positive_pair(index)
            if data1 is not None and data2 is not None:
                return data1, data2, label
        else:
            data1, data2, label = self._get_negative_pair(index)
            if data1 is not None and data2 is not None:
                return data1, data2, label

        other_index = random.randint(0, len(self.dataset) - 1)
        return self.dataset[index], self.dataset[other_index], torch.tensor([0.0], dtype=torch.float)